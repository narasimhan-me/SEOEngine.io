// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User roles for access control
enum UserRole {
  USER
  ADMIN
}

// [ADMIN-OPS-1] Internal admin roles (internal-only, not customer-facing)
enum InternalAdminRole {
  SUPPORT_AGENT
  OPS_ADMIN
  MANAGEMENT_CEO
}

// [SELF-SERVICE-1] Customer-facing account roles (separate from internal UserRole)
enum CustomerAccountRole {
  OWNER
  EDITOR
  VIEWER
}

// [ROLES-3] Project-level member roles for true multi-user projects
enum ProjectMemberRole {
  OWNER
  EDITOR
  VIEWER
}

// [SELF-SERVICE-1] Session type enumeration
enum SessionType {
  USER_LOGIN
  // Future types can be added here
}

// [ADMIN-OPS-1] Account status for users
enum AccountStatus {
  ACTIVE
  SUSPENDED
}

// Supported ecommerce platform integration types
enum IntegrationType {
  SHOPIFY
  WOOCOMMERCE
  BIGCOMMERCE
  MAGENTO
  CUSTOM_WEBSITE
}

enum CrawlFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

enum AutomationTargetType {
  PRODUCT
  PAGE
}

enum AutomationIssueType {
  MISSING_METADATA
  THIN_CONTENT
}

enum AutomationPlaybookDraftStatus {
  READY
  PARTIAL
  FAILED
  EXPIRED
}

enum AutomationPlaybookRunType {
  PREVIEW_GENERATE
  DRAFT_GENERATE
  APPLY
  INTENT_FIX_PREVIEW  // SEARCH-INTENT-1: Intent fix preview generation
  GEO_FIX_PREVIEW     // GEO-FOUNDATION-1: GEO fix preview generation
}

enum AutomationPlaybookRunStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  FAILED
  CANCELLED
  STALE
}

model User {
  id               String              @id @default(cuid())
  email            String              @unique
  password         String
  name             String?
  role             UserRole            @default(USER)
  twoFactorEnabled Boolean             @default(false)
  twoFactorSecret  String?             // Base32-encoded TOTP secret
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  // [ADMIN-OPS-1] Internal admin role and account status
  adminRole        InternalAdminRole?  // Nullable; only meaningful when role === ADMIN
  accountStatus    AccountStatus       @default(ACTIVE)

  // [SELF-SERVICE-1] Customer-facing account role and profile fields
  accountRole      CustomerAccountRole @default(OWNER)
  avatarUrl        String?
  timezone         String?
  locale           String?
  organizationName String?

  // [SELF-SERVICE-1] Security fields
  lastLoginAt         DateTime?
  lastLoginIp         String?
  tokenInvalidBefore  DateTime?   // For "sign out all sessions"

  // [SELF-SERVICE-1] Relations
  preferences          UserPreferences?
  sessions             UserSession[]
  userAccountAuditLogs UserAccountAuditLog[]

  projects     Project[]
  subscription Subscription?
  aiUsageEvents AiUsageEvent[]
  automationPlaybookRuns AutomationPlaybookRun[]
  intentFixApplications ProductIntentFixApplication[]
  competitiveFixApplications ProductCompetitiveFixApplication[]
  offsiteFixApplications ProjectOffsiteFixApplication[]
  localFixApplications ProjectLocalFixApplication[]
  mediaFixApplications ProductMediaFixApplication[]
  geoFixApplications ProductGeoFixApplication[]

  // [ADMIN-OPS-1] Admin audit log relations
  adminAuditLogsPerformed AdminAuditLog[] @relation("PerformedBy")
  adminAuditLogsTargeted  AdminAuditLog[] @relation("TargetUser")
  aiQuotaResetsPerformed  AiMonthlyQuotaReset[] @relation("CreatedBy")
  aiQuotaResetsReceived   AiMonthlyQuotaReset[] @relation("UserReset")

  // [ROLES-3] Project memberships (multi-user projects)
  projectMemberships      ProjectMember[]
}

model Project {
  id                         String             @id @default(cuid())
  user                       User               @relation(fields: [userId], references: [id])
  userId                     String
  name                       String
  domain                     String?
  createdAt                  DateTime           @default(now())
  currentDeoScore            Int?
  currentDeoScoreComputedAt  DateTime?
  lastCrawledAt              DateTime?
  lastDeoComputedAt          DateTime?
  autoCrawlEnabled           Boolean            @default(true)
  crawlFrequency             CrawlFrequency     @default(DAILY)
  autoSuggestMissingMetadata Boolean            @default(false)
  autoSuggestThinContent     Boolean            @default(false)
  autoSuggestDailyCap        Int                @default(50)

  aeoSyncToShopifyMetafields Boolean            @default(false)

  // [AUTOMATION-TRIGGER-TRUTHFULNESS-1] Project-level gate for Answer Block automation on product sync
  autoGenerateAnswerBlocksOnProductSync Boolean @default(false)

  integrations               Integration[]
  crawlResults               CrawlResult[]
  products                   Product[]
  deoScoreSnapshots          DeoScoreSnapshot[]
  automationSuggestions      AutomationSuggestion[]
  automationPlaybookDrafts   AutomationPlaybookDraft[]
  aiUsageEvents              AiUsageEvent[]
  automationPlaybookRuns     AutomationPlaybookRun[]

  // OFFSITE-1 relations
  offsiteSignals             ProjectOffsiteSignal[]
  offsiteCoverages           ProjectOffsiteCoverage[]
  offsiteFixDrafts           ProjectOffsiteFixDraft[]
  offsiteFixApplications     ProjectOffsiteFixApplication[]

  // LOCAL-1 relations
  localConfig                ProjectLocalConfig?
  localCoverages             ProjectLocalCoverage[]
  localSignals               ProjectLocalSignal[]
  localFixDrafts             ProjectLocalFixDraft[]
  localFixApplications       ProjectLocalFixApplication[]

  // [ADMIN-OPS-1] Admin audit log relation
  adminAuditLogsTargeted     AdminAuditLog[] @relation("TargetProject")

  // [GEO-EXPORT-1] GEO report share links
  geoReportShareLinks        GeoReportShareLink[]

  // [ENTERPRISE-GEO-1] Governance relations
  governancePolicy           ProjectGovernancePolicy?
  approvalRequests           ApprovalRequest[]
  governanceAuditEvents      GovernanceAuditEvent[]

  // [ROLES-3] Project members (multi-user projects)
  members                    ProjectMember[]
}

model Integration {
  id          String          @id @default(cuid())
  project     Project         @relation(fields: [projectId], references: [id])
  projectId   String
  type        IntegrationType
  externalId  String?         // shop domain, store ID, account slug, etc.
  accessToken String?         // shopify token, woo API key, etc.
  config      Json?           // platform-specific configuration
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@unique([projectId, type]) // One integration per type per project
}

model Product {
  id             String   @id @default(cuid())
  project        Project  @relation(fields: [projectId], references: [id])
  projectId      String
  externalId     String   // platform-agnostic ID (was shopifyId)
  title          String
  description    String?
  handle         String?  // [LIST-SEARCH-FILTER-1] Shopify handle for URL-based search
  seoTitle       String?
  seoDescription String?
  imageUrls      Json?
  lastSyncedAt   DateTime @default(now())

  answerBlocks         AnswerBlock[]
  intentCoverages      ProductIntentCoverage[]
  intentFixDrafts      ProductIntentFixDraft[]
  intentFixApplications ProductIntentFixApplication[]

  // GEO-FOUNDATION-1 relations
  geoFixDrafts                   ProductGeoFixDraft[]
  geoFixApplications             ProductGeoFixApplication[]

  // COMPETITORS-1 relations
  competitors                    ProductCompetitor[]
  competitiveCoverage            ProductCompetitiveCoverage?
  competitiveFixDrafts           ProductCompetitiveFixDraft[]
  competitiveFixApplications     ProductCompetitiveFixApplication[]

  // MEDIA-1 relations
  images                         ProductImage[]
  mediaFixDrafts                 ProductMediaFixDraft[]
  mediaFixApplications           ProductMediaFixApplication[]
}

model AnswerBlock {
  id               String   @id @default(cuid())
  product          Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId        String
  questionId       String
  questionText     String
  answerText       String
  confidenceScore  Float
  sourceType       String   @default("generated")
  sourceFieldsUsed String[] @default([])
  version          String   @default("ae_v1")
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@unique([productId, questionId])
  @@index([productId])
}

model AnswerBlockAutomationLog {
  id               String   @id @default(cuid())
  projectId        String
  productId        String
  triggerType      String
  planId           String
  action           String
  beforeAnswerBlocks Json?
  afterAnswerBlocks  Json?
  status           String   // succeeded | failed | skipped
  errorMessage     String?
  modelUsed        String?
  tokenEstimate    Int?
  createdAt        DateTime @default(now())

  @@index([projectId, productId, createdAt])
}

model CrawlResult {
  id              String   @id @default(cuid())
  project         Project  @relation(fields: [projectId], references: [id])
  projectId       String
  url             String
  statusCode      Int
  title           String?
  metaDescription String?
  h1              String?
  wordCount       Int?
  loadTimeMs      Int?
  issues          Json
  scannedAt       DateTime @default(now())

  // [SHOPIFY-ASSET-SYNC-COVERAGE-1] Shopify identity fields for Pages/Collections
  shopifyResourceType String?   // "PAGE" | "COLLECTION" | "ARTICLE"
  shopifyResourceId   String?   // Shopify numeric ID extracted from GID
  shopifyHandle       String?   // Handle as returned by Shopify
  shopifyBlogHandle   String?   // [BLOGS-ASSET-SYNC-COVERAGE-1] Parent blog handle for articles (e.g., "news")
  shopifyUpdatedAt    DateTime? // Shopify object updatedAt
  shopifyPublishedAt  DateTime? // [BLOGS-ASSET-SYNC-COVERAGE-1] Shopify article publishedAt (null => draft)
  shopifySyncedAt     DateTime? // Last successful sync time for this row

  // [SHOPIFY-ASSET-SYNC-COVERAGE-1] Compound unique for upsert identity
  @@unique([projectId, shopifyResourceType, shopifyResourceId])
  @@index([projectId, shopifyResourceType])
  @@index([projectId, url])
}

model AutomationSuggestion {
  id                   String               @id @default(cuid())
  project              Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId            String
  targetType           AutomationTargetType
  targetId             String
  issueType            AutomationIssueType
  suggestedTitle       String?
  suggestedDescription String?
  suggestedH1          String?
  generatedAt          DateTime             @default(now())
  source               String               @default("automation_v1")
  applied              Boolean              @default(false)
  appliedAt            DateTime?

  @@unique([projectId, targetType, targetId, issueType])
}

model Subscription {
  id                   String    @id @default(cuid())
  user                 User      @relation(fields: [userId], references: [id])
  userId               String    @unique // One subscription per user
  plan                 String    // e.g., "free", "starter", "pro", "enterprise"
  stripeCustomerId     String?
  stripeSubscriptionId String?
  status               String    @default("active") // active, canceled, past_due, etc.
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  lastStripeEventId    String?   // idempotency guard for Stripe webhooks
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
}

model DeoScoreSnapshot {
  id              String   @id @default(cuid())
  project         Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId       String
  overallScore    Int
  contentScore    Int?
  entityScore     Int?
  technicalScore  Int?
  visibilityScore Int?
  version         String   @default("v1")
  metadata        Json?
  computedAt      DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([projectId, computedAt(sort: Desc)])
}

model AiUsageEvent {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  feature   String
  createdAt DateTime @default(now())

  @@index([userId, feature, createdAt])
  @@index([projectId, feature, createdAt])
}

model TokenUsage {
  id        String   @id @default(cuid())
  userId    String
  source    String   // e.g. "metadata", "automation:playbook:missing_seo_title"
  amount    Int
  createdAt DateTime @default(now())
}

model AutomationPlaybookDraft {
  id              String                        @id @default(cuid())
  project         Project                       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId       String
  playbookId      String
  scopeId         String
  rulesHash       String
  status          AutomationPlaybookDraftStatus @default(PARTIAL)
  sampleProductIds Json?
  draftItems      Json?
  counts          Json?
  rules           Json?
  createdByUserId String
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt
  expiresAt       DateTime?

  // [WORK-QUEUE-1] Applied state tracking for "Applied Recently" tab derivation
  appliedAt       DateTime?                     // When this draft was successfully applied
  appliedByUserId String?                       // User who applied this draft

  @@unique([projectId, playbookId, scopeId, rulesHash])
  @@index([projectId, playbookId, updatedAt(sort: Desc)])
}

model AutomationPlaybookRun {
  id               String                        @id @default(cuid())
  project          Project                       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId        String
  createdBy        User                          @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)
  createdByUserId  String
  playbookId       String
  runType          AutomationPlaybookRunType
  status           AutomationPlaybookRunStatus   @default(QUEUED)
  scopeId          String
  rulesHash        String
  draftId          String?                       // references AutomationPlaybookDraft.id (no FK for v1)
  idempotencyKey   String
  aiUsed           Boolean                       @default(false)
  errorCode        String?
  errorMessage     String?
  resultRef        String?                       // e.g., changeset id or summary key
  meta             Json?
  createdAt        DateTime                      @default(now())
  updatedAt        DateTime                      @updatedAt

  // CACHE/REUSE v2: Deterministic reuse tracking
  aiWorkKey        String?                       // SHA-256 hash of (playbookId, productIds, rules) for AI work deduplication
  reused           Boolean                       @default(false)
  reusedFromRunId  String?                       // references the run whose AI work was reused

  @@index([projectId, createdAt(sort: Desc)])
  @@index([projectId, playbookId, runType, createdAt(sort: Desc)])
  @@index([projectId, scopeId, runType, createdAt(sort: Desc)])
  @@index([projectId, playbookId, runType, aiWorkKey])
  @@unique([projectId, playbookId, runType, scopeId, rulesHash, idempotencyKey])
}

// ============================================================================
// [AUTOMATION-TRIGGER-TRUTHFULNESS-1] Answer Block Automation Run Tracking
// ============================================================================

enum AnswerBlockAutomationRunStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  SKIPPED
  FAILED
}

/// [AUTOMATION-TRIGGER-TRUTHFULNESS-1] Durable idempotency storage for Answer Block automation runs.
/// Prevents duplicate AI generation for the same product state on product_synced trigger.
model AnswerBlockAutomationRun {
  id              String                         @id @default(cuid())
  projectId       String
  productId       String
  triggerType     String                         // 'product_synced' | 'issue_detected' | 'manual'
  idempotencyKey  String                         // Derived from {projectId, productId, automationType, fingerprintHash}
  fingerprintHash String                         // SHA-256 hash of stable product state (no timestamps)
  status          AnswerBlockAutomationRunStatus @default(QUEUED)
  planId          String?                        // Plan at time of enqueue (for audit)
  errorMessage    String?                        // Safe error message (no prompts/content)
  createdAt       DateTime                       @default(now())
  updatedAt       DateTime                       @updatedAt
  startedAt       DateTime?
  completedAt     DateTime?

  @@unique([projectId, productId, idempotencyKey])
  @@index([projectId, productId])
  @@index([idempotencyKey])
  @@index([projectId, status])
}

// ============================================================================
// SEARCH-INTENT-1: Search & Intent Pillar Models
// ============================================================================

enum SearchIntentType {
  INFORMATIONAL
  COMPARATIVE
  TRANSACTIONAL
  PROBLEM_USE_CASE
  TRUST_VALIDATION
}

enum IntentCoverageStatus {
  NONE
  WEAK
  PARTIAL
  COVERED
}

enum IntentFixDraftType {
  ANSWER_BLOCK
  CONTENT_SNIPPET
  METADATA_GUIDANCE
}

enum IntentFixApplyTarget {
  ANSWER_BLOCK
  CONTENT_SNIPPET_SECTION
}

// =============================================================================
// GEO-FOUNDATION-1: Answer Readiness & Citation Confidence (Draft-first fixes)
// =============================================================================

enum GeoIssueType {
  MISSING_DIRECT_ANSWER
  ANSWER_TOO_VAGUE
  POOR_ANSWER_STRUCTURE
  ANSWER_OVERLY_PROMOTIONAL
  MISSING_EXAMPLES_OR_FACTS
}

enum GeoCitationConfidenceLevel {
  LOW
  MEDIUM
  HIGH
}

// Per-product intent coverage analysis
model ProductIntentCoverage {
  id              String              @id @default(cuid())
  product         Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  intentType      SearchIntentType
  score           Float               // 0-100 coverage score
  coverageStatus  IntentCoverageStatus
  missingQueries  Json                // string[] of queries with no coverage
  weakQueries     Json                // string[] of queries with weak coverage
  coveredQueries  Json                // string[] of queries with strong coverage
  expectedQueries Json                // string[] of all expected queries for this intent
  computedAt      DateTime            @default(now())
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@unique([productId, intentType])
  @@index([productId, computedAt(sort: Desc)])
}

// Draft fixes for intent coverage gaps (preview-first pattern)
model ProductIntentFixDraft {
  id               String              @id @default(cuid())
  product          Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId        String
  intentType       SearchIntentType
  query            String              // The specific query this draft addresses
  draftType        IntentFixDraftType
  draftPayload     Json                // Answer Block structure or content snippet
  aiWorkKey        String              // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?            // If reused, the original work key
  generatedWithAi  Boolean             @default(true)
  expiresAt        DateTime?           // Optional TTL for draft expiry
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  applications     ProductIntentFixApplication[]

  @@index([productId, intentType, query])
  @@index([aiWorkKey])
  @@index([productId, expiresAt])
}

// Audit log for applied intent fixes
model ProductIntentFixApplication {
  id              String              @id @default(cuid())
  product         Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  draft           ProductIntentFixDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  intentType      SearchIntentType
  query           String
  applyTarget     IntentFixApplyTarget
  notes           String?
  appliedAt       DateTime            @default(now())

  @@index([productId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// Draft fixes for GEO answer readiness issues (preview-first pattern)
model ProductGeoFixDraft {
  id                String                        @id @default(cuid())
  product           Product                       @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId         String
  questionId        String
  issueType         GeoIssueType
  draftPayload      Json
  aiWorkKey         String
  reusedFromWorkKey String?
  generatedWithAi   Boolean                       @default(true)
  expiresAt         DateTime?
  createdAt         DateTime                      @default(now())
  updatedAt         DateTime                      @updatedAt

  applications      ProductGeoFixApplication[]

  @@index([productId, questionId, issueType])
  @@index([aiWorkKey])
  @@index([productId, expiresAt])
}

// Audit log for applied GEO fixes
model ProductGeoFixApplication {
  id                  String                      @id @default(cuid())
  product             Product                     @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId           String
  draft               ProductGeoFixDraft          @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId             String
  appliedBy           User                        @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId     String
  questionId          String
  issueType           GeoIssueType
  beforeConfidence    GeoCitationConfidenceLevel
  afterConfidence     GeoCitationConfidenceLevel
  beforeIssuesCount   Int
  afterIssuesCount    Int
  issuesResolvedCount Int
  resolvedIssueTypes  String[]                    @default([])
  appliedAt           DateTime                    @default(now())

  @@index([productId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// COMPETITORS-1: Competitive Positioning Models
// =============================================================================

// Competitive gap type enumeration
enum CompetitorGapType {
  INTENT_GAP
  CONTENT_SECTION_GAP
  TRUST_SIGNAL_GAP
}

// Competitive coverage status
enum CompetitiveStatus {
  AHEAD
  ON_PAR
  BEHIND
}

// Competitive fix draft type
enum CompetitiveFixDraftType {
  ANSWER_BLOCK
  COMPARISON_COPY
  POSITIONING_SECTION
}

// Competitive fix apply target
enum CompetitiveFixApplyTarget {
  ANSWER_BLOCK
  CONTENT_SECTION
  WHY_CHOOSE_SECTION
}

// Competitor references for a product (max 3 per product, enforced by app logic)
model ProductCompetitor {
  id          String   @id @default(cuid())
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId   String
  displayName String
  logoUrl     String?
  homepageUrl String?
  source      String   // 'heuristic_collection' | 'heuristic_category' | 'merchant_configured'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([productId])
}

// Per-product competitive coverage data
model ProductCompetitiveCoverage {
  id              String            @id @default(cuid())
  product         Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String            @unique
  coverageData    Json              // Full coverage areas as JSON
  overallScore    Float             // 0-100 competitive score
  areasWhereCompetitorsLead Int     // Count of areas where competitors lead
  status          CompetitiveStatus // AHEAD, ON_PAR, BEHIND
  computedAt      DateTime          @default(now())
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([productId, computedAt(sort: Desc)])
}

// Draft fixes for competitive gaps (preview-first pattern)
model ProductCompetitiveFixDraft {
  id                String                  @id @default(cuid())
  product           Product                 @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId         String
  gapType           CompetitorGapType
  intentType        SearchIntentType?       // For intent gaps
  areaId            String                  // Coverage area identifier
  draftType         CompetitiveFixDraftType
  draftPayload      Json                    // Answer Block or content structure
  aiWorkKey         String                  // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?                 // If reused, the original work key
  generatedWithAi   Boolean                 @default(true)
  expiresAt         DateTime?
  createdAt         DateTime                @default(now())
  updatedAt         DateTime                @updatedAt

  applications      ProductCompetitiveFixApplication[]

  @@index([productId, gapType, areaId])
  @@index([aiWorkKey])
  @@index([productId, expiresAt])
}

// Audit log of applied competitive fixes
model ProductCompetitiveFixApplication {
  id              String                    @id @default(cuid())
  product         Product                   @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  draft           ProductCompetitiveFixDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                      @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  gapType         CompetitorGapType
  intentType      SearchIntentType?
  areaId          String
  applyTarget     CompetitiveFixApplyTarget
  notes           String?
  appliedAt       DateTime                  @default(now())

  @@index([productId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// OFFSITE-1: Off-site Signals Models
// =============================================================================

// Off-site signal type enumeration
enum OffsiteSignalType {
  BRAND_MENTION
  AUTHORITATIVE_LISTING
  TRUST_PROOF
  REFERENCE_CONTENT
}

// Off-site gap type enumeration
enum OffsiteGapType {
  MISSING_BRAND_MENTIONS
  MISSING_TRUST_PROOF
  MISSING_AUTHORITATIVE_LISTING
  COMPETITOR_HAS_OFFSITE_SIGNAL
}

// Off-site fix draft type enumeration
enum OffsiteFixDraftType {
  OUTREACH_EMAIL
  PR_PITCH
  BRAND_PROFILE_SNIPPET
  REVIEW_REQUEST_COPY
}

// Off-site fix apply target enumeration
enum OffsiteFixApplyTarget {
  NOTES
  CONTENT_WORKSPACE
  OUTREACH_DRAFTS
}

// Off-site presence status
enum OffsitePresenceStatus {
  LOW
  MEDIUM
  STRONG
}

// Project-level off-site signal records
model ProjectOffsiteSignal {
  id               String            @id @default(cuid())
  project          Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId        String
  signalType       OffsiteSignalType
  sourceName       String            // Platform, publication, directory name
  url              String?           // Optional URL (may be absent for "no signals detected" cases)
  evidence         String            // Short description the UI can show
  merchantProvided Boolean           @default(false)
  knownPlatform    Boolean           @default(false)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@index([projectId, signalType])
}

// Project-level off-site coverage snapshot
model ProjectOffsiteCoverage {
  id           String                @id @default(cuid())
  project      Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId    String
  coverageData Json                  // Serialized coverage summary (counts per signal type and gaps)
  overallScore Float                 // 0-100 presence score
  status       OffsitePresenceStatus // LOW, MEDIUM, STRONG
  computedAt   DateTime              @default(now())
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt

  @@index([projectId, computedAt(sort: Desc)])
}

// Off-site fix drafts (preview-first pattern)
model ProjectOffsiteFixDraft {
  id                String              @id @default(cuid())
  project           Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId         String
  productId         String?             // Optional: if scoped to product-level (nullable for v1, brand-level emphasis)
  gapType           OffsiteGapType
  signalType        OffsiteSignalType
  focusKey          String              // Specific opportunity identifier (e.g., "reviews/trustpilot", "directory:industry")
  draftType         OffsiteFixDraftType
  draftPayload      Json                // Outreach/PR/profile/review request content
  aiWorkKey         String              // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?             // If reused, the original work key
  generatedWithAi   Boolean             @default(true)
  expiresAt         DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  applications      ProjectOffsiteFixApplication[]

  @@index([projectId, gapType, signalType, focusKey])
  @@index([aiWorkKey])
  @@index([projectId, expiresAt])
}

// Audit log of applied off-site fixes
model ProjectOffsiteFixApplication {
  id              String                @id @default(cuid())
  project         Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId       String
  productId       String?               // Optional: if scoped to product-level
  draft           ProjectOffsiteFixDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                  @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  gapType         OffsiteGapType
  signalType      OffsiteSignalType
  focusKey        String
  applyTarget     OffsiteFixApplyTarget
  notes           String?
  appliedAt       DateTime              @default(now())

  @@index([projectId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// LOCAL-1: Local Discovery Models
// =============================================================================

// Local applicability status enumeration
enum LocalApplicabilityStatus {
  APPLICABLE
  NOT_APPLICABLE
  UNKNOWN
}

// Local signal type enumeration
enum LocalSignalType {
  LOCATION_PRESENCE
  LOCAL_INTENT_COVERAGE
  LOCAL_TRUST_SIGNALS
  LOCAL_SCHEMA_READINESS
}

// Local gap type enumeration
enum LocalGapType {
  MISSING_LOCAL_INTENT_COVERAGE
  MISSING_LOCATION_CONTENT
  UNCLEAR_SERVICE_AREA
  MISSING_LOCAL_TRUST_SIGNAL
}

// Local fix draft type enumeration
enum LocalFixDraftType {
  LOCAL_ANSWER_BLOCK
  CITY_SECTION
  SERVICE_AREA_DESCRIPTION
}

// Local fix apply target enumeration
enum LocalFixApplyTarget {
  ANSWER_BLOCK
  CONTENT_SECTION
}

// Local coverage status
enum LocalCoverageStatus {
  STRONG
  NEEDS_IMPROVEMENT
  WEAK
}

// Project-level local configuration (merchant-declared settings)
model ProjectLocalConfig {
  id                      String   @id @default(cuid())
  project                 Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId               String   @unique
  hasPhysicalLocation     Boolean  @default(false)
  serviceAreaDescription  String?
  enabled                 Boolean  @default(false)  // Manual override to enable local discovery
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@index([projectId])
}

// Project-level local coverage snapshot
model ProjectLocalCoverage {
  id                        String                  @id @default(cuid())
  project                   Project                 @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId                 String
  applicabilityStatus       LocalApplicabilityStatus
  applicabilityReasons      Json                    // LocalApplicabilityReason[]
  score                     Float?                  // 0-100; null if not applicable
  status                    LocalCoverageStatus?    // null if not applicable
  signalCounts              Json                    // Record<LocalSignalType, number>
  missingLocalSignalsCount  Int                     @default(0)
  computedAt                DateTime                @default(now())
  createdAt                 DateTime                @default(now())
  updatedAt                 DateTime                @updatedAt

  @@index([projectId, computedAt(sort: Desc)])
}

// Project-level local signal records
model ProjectLocalSignal {
  id          String          @id @default(cuid())
  project     Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId   String
  signalType  LocalSignalType
  label       String
  description String
  url         String?
  evidence    String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([projectId, signalType])
}

// Local fix drafts (preview-first pattern)
model ProjectLocalFixDraft {
  id                String            @id @default(cuid())
  project           Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId         String
  productId         String?           // Optional: if scoped to product-level
  gapType           LocalGapType
  signalType        LocalSignalType
  focusKey          String            // e.g., "city:denver", "service_area:front_range"
  draftType         LocalFixDraftType
  draftPayload      Json              // Answer Block or content section structure
  aiWorkKey         String            // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?           // If reused, the original work key
  generatedWithAi   Boolean           @default(true)
  expiresAt         DateTime?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  applications      ProjectLocalFixApplication[]

  @@index([projectId, gapType, signalType, focusKey])
  @@index([aiWorkKey])
  @@index([projectId, expiresAt])
}

// Audit log of applied local fixes
model ProjectLocalFixApplication {
  id              String               @id @default(cuid())
  project         Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId       String
  productId       String?              // Optional: if scoped to product-level
  draft           ProjectLocalFixDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                 @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  gapType         LocalGapType
  signalType      LocalSignalType
  focusKey        String
  applyTarget     LocalFixApplyTarget
  notes           String?
  appliedAt       DateTime             @default(now())

  @@index([projectId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// MEDIA-1: Media & Accessibility Models
// =============================================================================

// Media fix draft type enumeration
enum MediaFixDraftType {
  IMAGE_ALT_TEXT
  IMAGE_CAPTION
}

// Media fix apply target enumeration
enum MediaFixApplyTarget {
  IMAGE_ALT
  CAPTION_FIELD
}

// Per-product image records (stores URL, alt text, caption per image)
model ProductImage {
  id         String   @id @default(cuid())
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId  String
  externalId String   // Shopify image ID (numeric or GID string)
  src        String   // Image URL
  altText    String?  // Current alt text
  position   Int?     // Display order
  caption    String?  // Optional caption
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([productId, externalId])
  @@index([productId])
}

// Media fix drafts (preview-first pattern)
model ProductMediaFixDraft {
  id                String            @id @default(cuid())
  product           Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId         String
  imageId           String            // Image external ID or internal key
  draftType         MediaFixDraftType
  draftPayload      Json              // { altText?: string, caption?: string }
  aiWorkKey         String            // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?           // If reused, the original work key
  generatedWithAi   Boolean           @default(true)
  expiresAt         DateTime?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  applications      ProductMediaFixApplication[]

  @@index([productId, imageId, draftType])
  @@index([aiWorkKey])
  @@index([productId, expiresAt])
}

// Audit log of applied media fixes
model ProductMediaFixApplication {
  id              String                @id @default(cuid())
  product         Product               @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  draft           ProductMediaFixDraft  @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                  @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  imageId         String                // Image external ID (as stored in draft)
  draftType       MediaFixDraftType
  applyTarget     MediaFixApplyTarget
  notes           String?
  appliedAt       DateTime              @default(now())

  @@index([productId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// ADMIN-OPS-1: Support & Management Operations Dashboard Models
// =============================================================================

// Immutable admin audit log (no update/delete flows)
model AdminAuditLog {
  id                    String              @id @default(cuid())
  createdAt             DateTime            @default(now())

  // Who performed the action
  performedBy           User                @relation("PerformedBy", fields: [performedByUserId], references: [id])
  performedByUserId     String
  performedByAdminRole  InternalAdminRole   // Denormalized snapshot of role at time

  // Action type (string enum-like for extensibility)
  actionType            String              // e.g., "impersonation", "quota_reset", "plan_override", "project_resync", "run_retry", "admin_role_change"

  // Optional targets
  targetUser            User?               @relation("TargetUser", fields: [targetUserId], references: [id])
  targetUserId          String?
  targetProject         Project?            @relation("TargetProject", fields: [targetProjectId], references: [id])
  targetProjectId       String?
  targetRunId           String?             // Nullable; string reference to AutomationPlaybookRun.id

  // Additional context (must avoid storing raw secrets/tokens)
  metadata              Json?

  @@index([createdAt(sort: Desc)])
  @@index([performedByUserId, createdAt(sort: Desc)])
  @@index([actionType, createdAt(sort: Desc)])
  @@index([targetUserId, createdAt(sort: Desc)])
  @@index([targetProjectId, createdAt(sort: Desc)])
}

// [ADMIN-OPS-1] Quota reset without deleting ledger (user-scoped, month-scoped)
model AiMonthlyQuotaReset {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())

  // Target user whose quota is being reset
  user            User     @relation("UserReset", fields: [userId], references: [id])
  userId          String

  // Month scope (normalized to UTC first-of-month)
  monthStart      DateTime

  // "Reset baseline" captured at reset time
  aiRunsOffset    Int

  // Who performed the reset (ops admin)
  createdByUser   User     @relation("CreatedBy", fields: [createdByUserId], references: [id])
  createdByUserId String

  // Optional reason for the reset
  reason          String?

  @@index([userId, monthStart])
  @@index([createdAt(sort: Desc)])
}

// =============================================================================
// SELF-SERVICE-1: Customer Self-Service Control Plane Models
// =============================================================================

// [SELF-SERVICE-1] User preferences (1:1 with User)
model UserPreferences {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @unique

  // Notification toggles
  notifyQuotaWarnings   Boolean @default(true)
  notifyRunFailures     Boolean @default(true)
  notifyWeeklyDeoSummary Boolean @default(true)

  // Default behaviors
  autoOpenIssuesTab       Boolean @default(false)
  preferredPillarLanding  String? // e.g., "metadata", "search_intent", etc.

  // Future-proofing JSON column for extensible preferences
  additionalPrefs Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// [SELF-SERVICE-1] Active sessions for "active sessions" visibility
model UserSession {
  id          String      @id @default(cuid())
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  sessionType SessionType @default(USER_LOGIN)

  createdAt   DateTime  @default(now())
  lastSeenAt  DateTime?
  revokedAt   DateTime?

  ip          String?
  userAgent   String?

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, revokedAt])
}

// [SELF-SERVICE-1] Customer audit log (immutable)
model UserAccountAuditLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Who performed the action (the user themselves)
  actorUser   User   @relation(fields: [actorUserId], references: [id], onDelete: Cascade)
  actorUserId String

  // Action type (extensible string enum)
  actionType  String // e.g., "profile_updated", "preferences_updated", "organization_updated", "sign_out_all_sessions", "disconnect_store"

  // Additional context (must avoid storing secrets)
  metadata    Json?

  @@index([actorUserId, createdAt(sort: Desc)])
  @@index([actionType, createdAt(sort: Desc)])
}

// [GEO-EXPORT-1] GEO Report Share Link status
enum GeoReportShareLinkStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

// [ENTERPRISE-GEO-1] Share link audience access modes
enum ShareLinkAudience {
  ANYONE_WITH_LINK  // Default: no auth required
  PASSCODE          // Requires system-generated passcode
  ORG_ONLY          // Placeholder: requires org membership (future)
}

// [GEO-EXPORT-1 + ENTERPRISE-GEO-1] Shareable link for GEO reports
// Public, time-bound (14-day default), revocable, with optional passcode protection
model GeoReportShareLink {
  id          String                   @id @default(cuid())
  project     Project                  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId   String

  // Non-discoverable token for public URL
  shareToken  String                   @unique @default(cuid())

  // Title/label for the share (optional)
  title       String?

  // Time window: 14-day default, can be reduced by governance policy
  createdAt   DateTime                 @default(now())
  expiresAt   DateTime                 // Set to createdAt + configured days

  // Revocation support
  status      GeoReportShareLinkStatus @default(ACTIVE)
  revokedAt   DateTime?

  // Snapshot timestamp for "generated at" display
  generatedAt DateTime                 @default(now())

  // Who created this share link (for audit)
  createdByUserId String

  // [ENTERPRISE-GEO-1] Export control fields
  audience           ShareLinkAudience  @default(ANYONE_WITH_LINK)
  passcodeHash       String?            // bcrypt hash of passcode (never store plaintext)
  passcodeLast4      String?            // Last 4 chars for hint display (e.g., "****ABCD")
  passcodeCreatedAt  DateTime?          // When passcode was set

  @@index([projectId, status])
  @@index([shareToken])
  @@index([expiresAt])
}

// =============================================================================
// ENTERPRISE-GEO-1: Enterprise Governance, Approvals, Audit, Export Controls
// =============================================================================

// [ENTERPRISE-GEO-1] Approval request status
enum ApprovalStatus {
  DRAFT             // Not yet submitted for approval
  PENDING_APPROVAL  // Awaiting decision
  APPROVED          // Approved by authorized actor
  REJECTED          // Rejected by authorized actor
}

// [ENTERPRISE-GEO-1] Resource types that can require approval
// [ROLES-2] Extended with AUTOMATION_PLAYBOOK_APPLY for playbook apply gating
enum ApprovalResourceType {
  GEO_FIX_APPLY              // Applying a GEO fix draft
  ANSWER_BLOCK_SYNC          // Syncing answer blocks to Shopify
  AUTOMATION_PLAYBOOK_APPLY  // [ROLES-2] Applying automation playbooks
}

// [ENTERPRISE-GEO-1] Audit event types for governance tracking
// [ROLES-3] Extended with project member management events
enum GovernanceAuditEventType {
  // Policy events
  POLICY_CHANGED

  // Approval workflow events
  APPROVAL_REQUESTED
  APPROVAL_APPROVED
  APPROVAL_REJECTED

  // Apply events (after approval)
  APPLY_EXECUTED

  // Share link events
  SHARE_LINK_CREATED
  SHARE_LINK_REVOKED

  // [ROLES-3] Project member management events
  PROJECT_MEMBER_ADDED
  PROJECT_MEMBER_REMOVED
  PROJECT_MEMBER_ROLE_CHANGED
}

// [ENTERPRISE-GEO-1] Project-scoped governance policy (1:1 with Project)
// Controls approval requirements, share link restrictions, and export controls
model ProjectGovernancePolicy {
  id        String   @id @default(cuid())
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String   @unique

  // Approval toggles (default off for backwards compatibility)
  requireApprovalForApply Boolean @default(false)  // Require approval before GEO/AEO apply

  // Share link restrictions
  restrictShareLinks    Boolean @default(false)    // If true: force passcode + shorter expiry
  shareLinkExpiryDays   Int     @default(14)       // Default expiry (max 14, reduced to 7 if restricted)
  allowedExportAudience ShareLinkAudience @default(ANYONE_WITH_LINK)  // Default audience mode

  // Export content controls (server-side enforcement)
  allowCompetitorMentionsInExports Boolean @default(false)  // Scrub competitor names if false
  allowPIIInExports                Boolean @default(false)  // Always false; scrub PII patterns

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// [ENTERPRISE-GEO-1] Approval workflow model
// Tracks approval requests for governed resources
model ApprovalRequest {
  id        String   @id @default(cuid())
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String

  // Resource being approved
  resourceType ApprovalResourceType
  resourceId   String                 // e.g., draftId for GEO_FIX_APPLY, productId for ANSWER_BLOCK_SYNC

  // Workflow state
  status ApprovalStatus @default(PENDING_APPROVAL)

  // Actor tracking
  requestedByUserId String             // User who submitted the request
  requestedAt       DateTime @default(now())

  // Decision tracking (null until decided)
  decidedByUserId String?              // User who approved/rejected
  decidedAt       DateTime?
  decisionReason  String?              // Optional reason for approval/rejection

  // Consumption tracking (prevents reusing approved requests)
  consumed   Boolean   @default(false) // True after the approved action is executed
  consumedAt DateTime?                 // When the approval was used

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projectId, resourceType, resourceId])
  @@index([projectId, status])
  @@index([requestedByUserId, createdAt(sort: Desc)])
}

// [ENTERPRISE-GEO-1] Immutable audit event log for governance actions
// Append-only: no update or delete flows
model GovernanceAuditEvent {
  id        String   @id @default(cuid())
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String

  // Who performed the action
  actorUserId String

  // What happened
  eventType    GovernanceAuditEventType
  resourceType String?                    // e.g., "GEO_FIX_APPLY", "SHARE_LINK", "POLICY"
  resourceId   String?                    // ID of the affected resource

  // Additional context (must never contain secrets/tokens)
  metadata Json?

  createdAt DateTime @default(now())

  @@index([projectId, createdAt(sort: Desc)])
  @@index([projectId, eventType, createdAt(sort: Desc)])
  @@index([actorUserId, createdAt(sort: Desc)])
}

// =============================================================================
// ROLES-3: True Multi-User Projects & Approval Chains
// =============================================================================

// [ROLES-3] Project membership model for true multi-user projects
// Links users to projects with specific roles
// Cascade deletion when project is deleted
model ProjectMember {
  id        String            @id @default(cuid())
  project   Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  role      ProjectMemberRole
  createdAt DateTime          @default(now())

  // Uniqueness: one membership per (projectId, userId)
  @@unique([projectId, userId])
  // Index for "list members by project"
  @@index([projectId])
  // Index for "resolve role by (projectId, userId)"
  @@index([projectId, userId])
  // Index for "list projects by user"
  @@index([userId])
}
