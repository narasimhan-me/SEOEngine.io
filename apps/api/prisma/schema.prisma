// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User roles for access control
enum UserRole {
  USER
  ADMIN
}

// Supported ecommerce platform integration types
enum IntegrationType {
  SHOPIFY
  WOOCOMMERCE
  BIGCOMMERCE
  MAGENTO
  CUSTOM_WEBSITE
}

enum CrawlFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

enum AutomationTargetType {
  PRODUCT
  PAGE
}

enum AutomationIssueType {
  MISSING_METADATA
  THIN_CONTENT
}

enum AutomationPlaybookDraftStatus {
  READY
  PARTIAL
  FAILED
  EXPIRED
}

enum AutomationPlaybookRunType {
  PREVIEW_GENERATE
  DRAFT_GENERATE
  APPLY
  INTENT_FIX_PREVIEW  // SEARCH-INTENT-1: Intent fix preview generation
}

enum AutomationPlaybookRunStatus {
  QUEUED
  RUNNING
  SUCCEEDED
  FAILED
  CANCELLED
  STALE
}

model User {
  id               String   @id @default(cuid())
  email            String   @unique
  password         String
  name             String?
  role             UserRole @default(USER)
  twoFactorEnabled Boolean  @default(false)
  twoFactorSecret  String?  // Base32-encoded TOTP secret
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  projects     Project[]
  subscription Subscription?
  aiUsageEvents AiUsageEvent[]
  automationPlaybookRuns AutomationPlaybookRun[]
  intentFixApplications ProductIntentFixApplication[]
  competitiveFixApplications ProductCompetitiveFixApplication[]
  offsiteFixApplications ProjectOffsiteFixApplication[]
  localFixApplications ProjectLocalFixApplication[]
  mediaFixApplications ProductMediaFixApplication[]
}

model Project {
  id                         String             @id @default(cuid())
  user                       User               @relation(fields: [userId], references: [id])
  userId                     String
  name                       String
  domain                     String?
  createdAt                  DateTime           @default(now())
  currentDeoScore            Int?
  currentDeoScoreComputedAt  DateTime?
  lastCrawledAt              DateTime?
  lastDeoComputedAt          DateTime?
  autoCrawlEnabled           Boolean            @default(true)
  crawlFrequency             CrawlFrequency     @default(DAILY)
  autoSuggestMissingMetadata Boolean            @default(false)
  autoSuggestThinContent     Boolean            @default(false)
  autoSuggestDailyCap        Int                @default(50)

  aeoSyncToShopifyMetafields Boolean            @default(false)

  integrations               Integration[]
  crawlResults               CrawlResult[]
  products                   Product[]
  deoScoreSnapshots          DeoScoreSnapshot[]
  automationSuggestions      AutomationSuggestion[]
  automationPlaybookDrafts   AutomationPlaybookDraft[]
  aiUsageEvents              AiUsageEvent[]
  automationPlaybookRuns     AutomationPlaybookRun[]

  // OFFSITE-1 relations
  offsiteSignals             ProjectOffsiteSignal[]
  offsiteCoverages           ProjectOffsiteCoverage[]
  offsiteFixDrafts           ProjectOffsiteFixDraft[]
  offsiteFixApplications     ProjectOffsiteFixApplication[]

  // LOCAL-1 relations
  localConfig                ProjectLocalConfig?
  localCoverages             ProjectLocalCoverage[]
  localSignals               ProjectLocalSignal[]
  localFixDrafts             ProjectLocalFixDraft[]
  localFixApplications       ProjectLocalFixApplication[]
}

model Integration {
  id          String          @id @default(cuid())
  project     Project         @relation(fields: [projectId], references: [id])
  projectId   String
  type        IntegrationType
  externalId  String?         // shop domain, store ID, account slug, etc.
  accessToken String?         // shopify token, woo API key, etc.
  config      Json?           // platform-specific configuration
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@unique([projectId, type]) // One integration per type per project
}

model Product {
  id             String   @id @default(cuid())
  project        Project  @relation(fields: [projectId], references: [id])
  projectId      String
  externalId     String   // platform-agnostic ID (was shopifyId)
  title          String
  description    String?
  seoTitle       String?
  seoDescription String?
  imageUrls      Json?
  lastSyncedAt   DateTime @default(now())

  answerBlocks         AnswerBlock[]
  intentCoverages      ProductIntentCoverage[]
  intentFixDrafts      ProductIntentFixDraft[]
  intentFixApplications ProductIntentFixApplication[]

  // COMPETITORS-1 relations
  competitors                    ProductCompetitor[]
  competitiveCoverage            ProductCompetitiveCoverage?
  competitiveFixDrafts           ProductCompetitiveFixDraft[]
  competitiveFixApplications     ProductCompetitiveFixApplication[]

  // MEDIA-1 relations
  images                         ProductImage[]
  mediaFixDrafts                 ProductMediaFixDraft[]
  mediaFixApplications           ProductMediaFixApplication[]
}

model AnswerBlock {
  id               String   @id @default(cuid())
  product          Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId        String
  questionId       String
  questionText     String
  answerText       String
  confidenceScore  Float
  sourceType       String   @default("generated")
  sourceFieldsUsed String[] @default([])
  version          String   @default("ae_v1")
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@unique([productId, questionId])
  @@index([productId])
}

model AnswerBlockAutomationLog {
  id               String   @id @default(cuid())
  projectId        String
  productId        String
  triggerType      String
  planId           String
  action           String
  beforeAnswerBlocks Json?
  afterAnswerBlocks  Json?
  status           String   // succeeded | failed | skipped
  errorMessage     String?
  modelUsed        String?
  tokenEstimate    Int?
  createdAt        DateTime @default(now())

  @@index([projectId, productId, createdAt])
}

model CrawlResult {
  id              String   @id @default(cuid())
  project         Project  @relation(fields: [projectId], references: [id])
  projectId       String
  url             String
  statusCode      Int
  title           String?
  metaDescription String?
  h1              String?
  wordCount       Int?
  loadTimeMs      Int?
  issues          Json
  scannedAt       DateTime @default(now())
}

model AutomationSuggestion {
  id                   String               @id @default(cuid())
  project              Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId            String
  targetType           AutomationTargetType
  targetId             String
  issueType            AutomationIssueType
  suggestedTitle       String?
  suggestedDescription String?
  suggestedH1          String?
  generatedAt          DateTime             @default(now())
  source               String               @default("automation_v1")
  applied              Boolean              @default(false)
  appliedAt            DateTime?

  @@unique([projectId, targetType, targetId, issueType])
}

model Subscription {
  id                   String    @id @default(cuid())
  user                 User      @relation(fields: [userId], references: [id])
  userId               String    @unique // One subscription per user
  plan                 String    // e.g., "free", "starter", "pro", "enterprise"
  stripeCustomerId     String?
  stripeSubscriptionId String?
  status               String    @default("active") // active, canceled, past_due, etc.
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  lastStripeEventId    String?   // idempotency guard for Stripe webhooks
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
}

model DeoScoreSnapshot {
  id              String   @id @default(cuid())
  project         Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId       String
  overallScore    Int
  contentScore    Int?
  entityScore     Int?
  technicalScore  Int?
  visibilityScore Int?
  version         String   @default("v1")
  metadata        Json?
  computedAt      DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([projectId, computedAt(sort: Desc)])
}

model AiUsageEvent {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  feature   String
  createdAt DateTime @default(now())

  @@index([userId, feature, createdAt])
  @@index([projectId, feature, createdAt])
}

model TokenUsage {
  id        String   @id @default(cuid())
  userId    String
  source    String   // e.g. "metadata", "automation:playbook:missing_seo_title"
  amount    Int
  createdAt DateTime @default(now())
}

model AutomationPlaybookDraft {
  id              String                        @id @default(cuid())
  project         Project                       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId       String
  playbookId      String
  scopeId         String
  rulesHash       String
  status          AutomationPlaybookDraftStatus @default(PARTIAL)
  sampleProductIds Json?
  draftItems      Json?
  counts          Json?
  rules           Json?
  createdByUserId String
  createdAt       DateTime                      @default(now())
  updatedAt       DateTime                      @updatedAt
  expiresAt       DateTime?

  @@unique([projectId, playbookId, scopeId, rulesHash])
  @@index([projectId, playbookId, updatedAt(sort: Desc)])
}

model AutomationPlaybookRun {
  id               String                        @id @default(cuid())
  project          Project                       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId        String
  createdBy        User                          @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)
  createdByUserId  String
  playbookId       String
  runType          AutomationPlaybookRunType
  status           AutomationPlaybookRunStatus   @default(QUEUED)
  scopeId          String
  rulesHash        String
  draftId          String?                       // references AutomationPlaybookDraft.id (no FK for v1)
  idempotencyKey   String
  aiUsed           Boolean                       @default(false)
  errorCode        String?
  errorMessage     String?
  resultRef        String?                       // e.g., changeset id or summary key
  meta             Json?
  createdAt        DateTime                      @default(now())
  updatedAt        DateTime                      @updatedAt

  // CACHE/REUSE v2: Deterministic reuse tracking
  aiWorkKey        String?                       // SHA-256 hash of (playbookId, productIds, rules) for AI work deduplication
  reused           Boolean                       @default(false)
  reusedFromRunId  String?                       // references the run whose AI work was reused

  @@index([projectId, createdAt(sort: Desc)])
  @@index([projectId, playbookId, runType, createdAt(sort: Desc)])
  @@index([projectId, scopeId, runType, createdAt(sort: Desc)])
  @@index([projectId, playbookId, runType, aiWorkKey])
  @@unique([projectId, playbookId, runType, scopeId, rulesHash, idempotencyKey])
}

// ============================================================================
// SEARCH-INTENT-1: Search & Intent Pillar Models
// ============================================================================

enum SearchIntentType {
  INFORMATIONAL
  COMPARATIVE
  TRANSACTIONAL
  PROBLEM_USE_CASE
  TRUST_VALIDATION
}

enum IntentCoverageStatus {
  NONE
  WEAK
  PARTIAL
  COVERED
}

enum IntentFixDraftType {
  ANSWER_BLOCK
  CONTENT_SNIPPET
  METADATA_GUIDANCE
}

enum IntentFixApplyTarget {
  ANSWER_BLOCK
  CONTENT_SNIPPET_SECTION
}

// Per-product intent coverage analysis
model ProductIntentCoverage {
  id              String              @id @default(cuid())
  product         Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  intentType      SearchIntentType
  score           Float               // 0-100 coverage score
  coverageStatus  IntentCoverageStatus
  missingQueries  Json                // string[] of queries with no coverage
  weakQueries     Json                // string[] of queries with weak coverage
  coveredQueries  Json                // string[] of queries with strong coverage
  expectedQueries Json                // string[] of all expected queries for this intent
  computedAt      DateTime            @default(now())
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@unique([productId, intentType])
  @@index([productId, computedAt(sort: Desc)])
}

// Draft fixes for intent coverage gaps (preview-first pattern)
model ProductIntentFixDraft {
  id               String              @id @default(cuid())
  product          Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId        String
  intentType       SearchIntentType
  query            String              // The specific query this draft addresses
  draftType        IntentFixDraftType
  draftPayload     Json                // Answer Block structure or content snippet
  aiWorkKey        String              // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?            // If reused, the original work key
  generatedWithAi  Boolean             @default(true)
  expiresAt        DateTime?           // Optional TTL for draft expiry
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt

  applications     ProductIntentFixApplication[]

  @@index([productId, intentType, query])
  @@index([aiWorkKey])
  @@index([productId, expiresAt])
}

// Audit log for applied intent fixes
model ProductIntentFixApplication {
  id              String              @id @default(cuid())
  product         Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  draft           ProductIntentFixDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  intentType      SearchIntentType
  query           String
  applyTarget     IntentFixApplyTarget
  notes           String?
  appliedAt       DateTime            @default(now())

  @@index([productId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// COMPETITORS-1: Competitive Positioning Models
// =============================================================================

// Competitive gap type enumeration
enum CompetitorGapType {
  INTENT_GAP
  CONTENT_SECTION_GAP
  TRUST_SIGNAL_GAP
}

// Competitive coverage status
enum CompetitiveStatus {
  AHEAD
  ON_PAR
  BEHIND
}

// Competitive fix draft type
enum CompetitiveFixDraftType {
  ANSWER_BLOCK
  COMPARISON_COPY
  POSITIONING_SECTION
}

// Competitive fix apply target
enum CompetitiveFixApplyTarget {
  ANSWER_BLOCK
  CONTENT_SECTION
  WHY_CHOOSE_SECTION
}

// Competitor references for a product (max 3 per product, enforced by app logic)
model ProductCompetitor {
  id          String   @id @default(cuid())
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId   String
  displayName String
  logoUrl     String?
  homepageUrl String?
  source      String   // 'heuristic_collection' | 'heuristic_category' | 'merchant_configured'
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([productId])
}

// Per-product competitive coverage data
model ProductCompetitiveCoverage {
  id              String            @id @default(cuid())
  product         Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String            @unique
  coverageData    Json              // Full coverage areas as JSON
  overallScore    Float             // 0-100 competitive score
  areasWhereCompetitorsLead Int     // Count of areas where competitors lead
  status          CompetitiveStatus // AHEAD, ON_PAR, BEHIND
  computedAt      DateTime          @default(now())
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([productId, computedAt(sort: Desc)])
}

// Draft fixes for competitive gaps (preview-first pattern)
model ProductCompetitiveFixDraft {
  id                String                  @id @default(cuid())
  product           Product                 @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId         String
  gapType           CompetitorGapType
  intentType        SearchIntentType?       // For intent gaps
  areaId            String                  // Coverage area identifier
  draftType         CompetitiveFixDraftType
  draftPayload      Json                    // Answer Block or content structure
  aiWorkKey         String                  // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?                 // If reused, the original work key
  generatedWithAi   Boolean                 @default(true)
  expiresAt         DateTime?
  createdAt         DateTime                @default(now())
  updatedAt         DateTime                @updatedAt

  applications      ProductCompetitiveFixApplication[]

  @@index([productId, gapType, areaId])
  @@index([aiWorkKey])
  @@index([productId, expiresAt])
}

// Audit log of applied competitive fixes
model ProductCompetitiveFixApplication {
  id              String                    @id @default(cuid())
  product         Product                   @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  draft           ProductCompetitiveFixDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                      @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  gapType         CompetitorGapType
  intentType      SearchIntentType?
  areaId          String
  applyTarget     CompetitiveFixApplyTarget
  notes           String?
  appliedAt       DateTime                  @default(now())

  @@index([productId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// OFFSITE-1: Off-site Signals Models
// =============================================================================

// Off-site signal type enumeration
enum OffsiteSignalType {
  BRAND_MENTION
  AUTHORITATIVE_LISTING
  TRUST_PROOF
  REFERENCE_CONTENT
}

// Off-site gap type enumeration
enum OffsiteGapType {
  MISSING_BRAND_MENTIONS
  MISSING_TRUST_PROOF
  MISSING_AUTHORITATIVE_LISTING
  COMPETITOR_HAS_OFFSITE_SIGNAL
}

// Off-site fix draft type enumeration
enum OffsiteFixDraftType {
  OUTREACH_EMAIL
  PR_PITCH
  BRAND_PROFILE_SNIPPET
  REVIEW_REQUEST_COPY
}

// Off-site fix apply target enumeration
enum OffsiteFixApplyTarget {
  NOTES
  CONTENT_WORKSPACE
  OUTREACH_DRAFTS
}

// Off-site presence status
enum OffsitePresenceStatus {
  LOW
  MEDIUM
  STRONG
}

// Project-level off-site signal records
model ProjectOffsiteSignal {
  id               String            @id @default(cuid())
  project          Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId        String
  signalType       OffsiteSignalType
  sourceName       String            // Platform, publication, directory name
  url              String?           // Optional URL (may be absent for "no signals detected" cases)
  evidence         String            // Short description the UI can show
  merchantProvided Boolean           @default(false)
  knownPlatform    Boolean           @default(false)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@index([projectId, signalType])
}

// Project-level off-site coverage snapshot
model ProjectOffsiteCoverage {
  id           String                @id @default(cuid())
  project      Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId    String
  coverageData Json                  // Serialized coverage summary (counts per signal type and gaps)
  overallScore Float                 // 0-100 presence score
  status       OffsitePresenceStatus // LOW, MEDIUM, STRONG
  computedAt   DateTime              @default(now())
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt

  @@index([projectId, computedAt(sort: Desc)])
}

// Off-site fix drafts (preview-first pattern)
model ProjectOffsiteFixDraft {
  id                String              @id @default(cuid())
  project           Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId         String
  productId         String?             // Optional: if scoped to product-level (nullable for v1, brand-level emphasis)
  gapType           OffsiteGapType
  signalType        OffsiteSignalType
  focusKey          String              // Specific opportunity identifier (e.g., "reviews/trustpilot", "directory:industry")
  draftType         OffsiteFixDraftType
  draftPayload      Json                // Outreach/PR/profile/review request content
  aiWorkKey         String              // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?             // If reused, the original work key
  generatedWithAi   Boolean             @default(true)
  expiresAt         DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  applications      ProjectOffsiteFixApplication[]

  @@index([projectId, gapType, signalType, focusKey])
  @@index([aiWorkKey])
  @@index([projectId, expiresAt])
}

// Audit log of applied off-site fixes
model ProjectOffsiteFixApplication {
  id              String                @id @default(cuid())
  project         Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId       String
  productId       String?               // Optional: if scoped to product-level
  draft           ProjectOffsiteFixDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                  @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  gapType         OffsiteGapType
  signalType      OffsiteSignalType
  focusKey        String
  applyTarget     OffsiteFixApplyTarget
  notes           String?
  appliedAt       DateTime              @default(now())

  @@index([projectId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// LOCAL-1: Local Discovery Models
// =============================================================================

// Local applicability status enumeration
enum LocalApplicabilityStatus {
  APPLICABLE
  NOT_APPLICABLE
  UNKNOWN
}

// Local signal type enumeration
enum LocalSignalType {
  LOCATION_PRESENCE
  LOCAL_INTENT_COVERAGE
  LOCAL_TRUST_SIGNALS
  LOCAL_SCHEMA_READINESS
}

// Local gap type enumeration
enum LocalGapType {
  MISSING_LOCAL_INTENT_COVERAGE
  MISSING_LOCATION_CONTENT
  UNCLEAR_SERVICE_AREA
  MISSING_LOCAL_TRUST_SIGNAL
}

// Local fix draft type enumeration
enum LocalFixDraftType {
  LOCAL_ANSWER_BLOCK
  CITY_SECTION
  SERVICE_AREA_DESCRIPTION
}

// Local fix apply target enumeration
enum LocalFixApplyTarget {
  ANSWER_BLOCK
  CONTENT_SECTION
}

// Local coverage status
enum LocalCoverageStatus {
  STRONG
  NEEDS_IMPROVEMENT
  WEAK
}

// Project-level local configuration (merchant-declared settings)
model ProjectLocalConfig {
  id                      String   @id @default(cuid())
  project                 Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId               String   @unique
  hasPhysicalLocation     Boolean  @default(false)
  serviceAreaDescription  String?
  enabled                 Boolean  @default(false)  // Manual override to enable local discovery
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@index([projectId])
}

// Project-level local coverage snapshot
model ProjectLocalCoverage {
  id                        String                  @id @default(cuid())
  project                   Project                 @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId                 String
  applicabilityStatus       LocalApplicabilityStatus
  applicabilityReasons      Json                    // LocalApplicabilityReason[]
  score                     Float?                  // 0-100; null if not applicable
  status                    LocalCoverageStatus?    // null if not applicable
  signalCounts              Json                    // Record<LocalSignalType, number>
  missingLocalSignalsCount  Int                     @default(0)
  computedAt                DateTime                @default(now())
  createdAt                 DateTime                @default(now())
  updatedAt                 DateTime                @updatedAt

  @@index([projectId, computedAt(sort: Desc)])
}

// Project-level local signal records
model ProjectLocalSignal {
  id          String          @id @default(cuid())
  project     Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId   String
  signalType  LocalSignalType
  label       String
  description String
  url         String?
  evidence    String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([projectId, signalType])
}

// Local fix drafts (preview-first pattern)
model ProjectLocalFixDraft {
  id                String            @id @default(cuid())
  project           Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId         String
  productId         String?           // Optional: if scoped to product-level
  gapType           LocalGapType
  signalType        LocalSignalType
  focusKey          String            // e.g., "city:denver", "service_area:front_range"
  draftType         LocalFixDraftType
  draftPayload      Json              // Answer Block or content section structure
  aiWorkKey         String            // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?           // If reused, the original work key
  generatedWithAi   Boolean           @default(true)
  expiresAt         DateTime?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  applications      ProjectLocalFixApplication[]

  @@index([projectId, gapType, signalType, focusKey])
  @@index([aiWorkKey])
  @@index([projectId, expiresAt])
}

// Audit log of applied local fixes
model ProjectLocalFixApplication {
  id              String               @id @default(cuid())
  project         Project              @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId       String
  productId       String?              // Optional: if scoped to product-level
  draft           ProjectLocalFixDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                 @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  gapType         LocalGapType
  signalType      LocalSignalType
  focusKey        String
  applyTarget     LocalFixApplyTarget
  notes           String?
  appliedAt       DateTime             @default(now())

  @@index([projectId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}

// =============================================================================
// MEDIA-1: Media & Accessibility Models
// =============================================================================

// Media fix draft type enumeration
enum MediaFixDraftType {
  IMAGE_ALT_TEXT
  IMAGE_CAPTION
}

// Media fix apply target enumeration
enum MediaFixApplyTarget {
  IMAGE_ALT
  CAPTION_FIELD
}

// Per-product image records (stores URL, alt text, caption per image)
model ProductImage {
  id         String   @id @default(cuid())
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId  String
  externalId String   // Shopify image ID (numeric or GID string)
  src        String   // Image URL
  altText    String?  // Current alt text
  position   Int?     // Display order
  caption    String?  // Optional caption
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([productId, externalId])
  @@index([productId])
}

// Media fix drafts (preview-first pattern)
model ProductMediaFixDraft {
  id                String            @id @default(cuid())
  product           Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId         String
  imageId           String            // Image external ID or internal key
  draftType         MediaFixDraftType
  draftPayload      Json              // { altText?: string, caption?: string }
  aiWorkKey         String            // Deterministic key for CACHE/REUSE v2
  reusedFromWorkKey String?           // If reused, the original work key
  generatedWithAi   Boolean           @default(true)
  expiresAt         DateTime?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  applications      ProductMediaFixApplication[]

  @@index([productId, imageId, draftType])
  @@index([aiWorkKey])
  @@index([productId, expiresAt])
}

// Audit log of applied media fixes
model ProductMediaFixApplication {
  id              String                @id @default(cuid())
  product         Product               @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId       String
  draft           ProductMediaFixDraft  @relation(fields: [draftId], references: [id], onDelete: Cascade)
  draftId         String
  appliedBy       User                  @relation(fields: [appliedByUserId], references: [id], onDelete: Cascade)
  appliedByUserId String
  imageId         String                // Image external ID (as stored in draft)
  draftType       MediaFixDraftType
  applyTarget     MediaFixApplyTarget
  notes           String?
  appliedAt       DateTime              @default(now())

  @@index([productId, appliedAt(sort: Desc)])
  @@index([appliedByUserId, appliedAt(sort: Desc)])
}
